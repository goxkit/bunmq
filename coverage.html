
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bunmq: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/goxkit/bunmq/binding.go (0.0%)</option>
				
				<option value="file1">github.com/goxkit/bunmq/channel.go (0.0%)</option>
				
				<option value="file2">github.com/goxkit/bunmq/connection_manager.go (0.0%)</option>
				
				<option value="file3">github.com/goxkit/bunmq/dispatcher.go (0.0%)</option>
				
				<option value="file4">github.com/goxkit/bunmq/errors.go (100.0%)</option>
				
				<option value="file5">github.com/goxkit/bunmq/exchange.go (0.0%)</option>
				
				<option value="file6">github.com/goxkit/bunmq/publisher.go (0.0%)</option>
				
				<option value="file7">github.com/goxkit/bunmq/queue.go (100.0%)</option>
				
				<option value="file8">github.com/goxkit/bunmq/topology.go (0.0%)</option>
				
				<option value="file9">github.com/goxkit/bunmq/tracing.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

type (
        // ExchangeBindingDefinition represents a binding between two exchanges.
        // It defines how messages are routed from a source exchange to a destination exchange
        // based on a routing key and optional arguments.
        ExchangeBindingDefinition struct {
                source      string
                destination string
                routingKey  string
                args        map[string]interface{}
        }

        // QueueBindingDefinition represents a binding between an exchange and a queue.
        // It defines how messages are routed from an exchange to a queue
        // based on a routing key and optional arguments.
        QueueBindingDefinition struct {
                routingKey string
                queue      string
                exchange   string
                args       map[string]interface{}
        }
)

// NewExchangeBiding creates a new exchange binding definition.
// This defines how messages are routed between exchanges.
//
// Exchange bindings allow for creating complex routing topologies where messages
// published to one exchange can be routed to another exchange based on routing rules.
// This is useful for scenarios like:
// - Broadcasting messages across multiple systems
// - Implementing fanout patterns from a direct exchange
// - Creating hierarchical routing structures
//
// Example:
//
//        // Define a binding from a direct to a fanout exchange
//        binding := rabbitmq.NewExchangeBiding()
//        binding.Source("orders").Destination("notifications").RoutingKey("new-order")
//
// Note: This binding needs to be added to the Topology with the ExchangeBinding method.
func NewExchangeBiding() *ExchangeBindingDefinition <span class="cov0" title="0">{
        return &amp;ExchangeBindingDefinition{}
}</span>

// NewQueueBinding creates a new queue binding definition.
// This defines how messages are routed from an exchange to a queue.
func NewQueueBinding() *QueueBindingDefinition <span class="cov0" title="0">{
        return &amp;QueueBindingDefinition{}
}</span>

// RoutingKey sets the routing key for this queue binding.
// The routing key is used to filter messages from the exchange to the queue.
func (b *QueueBindingDefinition) RoutingKey(key string) *QueueBindingDefinition <span class="cov0" title="0">{
        b.routingKey = key
        return b
}</span>

// Queue sets the queue name for this binding.
// This is the destination queue that will receive messages from the exchange.
func (b *QueueBindingDefinition) Queue(name string) *QueueBindingDefinition <span class="cov0" title="0">{
        b.queue = name
        return b
}</span>

// Exchange sets the exchange name for this binding.
// This is the source exchange from which messages will be routed to the queue.
func (b *QueueBindingDefinition) Exchange(name string) *QueueBindingDefinition <span class="cov0" title="0">{
        b.exchange = name
        return b
}</span>

// Args sets additional arguments for this queue binding.
// These are passed as arguments when declaring the binding.
func (b *QueueBindingDefinition) Args(args map[string]interface{}) *QueueBindingDefinition <span class="cov0" title="0">{
        b.args = args
        return b
}</span>

// Source sets the source exchange name for this binding.
// This is the exchange from which messages will be routed.
func (b *ExchangeBindingDefinition) Source(name string) *ExchangeBindingDefinition <span class="cov0" title="0">{
        b.source = name
        return b
}</span>

// Destination sets the destination exchange name for this binding.
// This is the exchange to which messages will be routed.
func (b *ExchangeBindingDefinition) Destination(name string) *ExchangeBindingDefinition <span class="cov0" title="0">{
        b.destination = name
        return b
}</span>

// RoutingKey sets the routing key for this exchange binding.
// The routing key is used to filter messages from the source to the destination exchange.
func (b *ExchangeBindingDefinition) RoutingKey(key string) *ExchangeBindingDefinition <span class="cov0" title="0">{
        b.routingKey = key
        return b
}</span>

// Args sets additional arguments for this exchange binding.
func (b *ExchangeBindingDefinition) Args(args map[string]interface{}) *ExchangeBindingDefinition <span class="cov0" title="0">{
        b.args = args
        return b
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/sirupsen/logrus"
)

type (
        // AMQPChannel defines the interface for a RabbitMQ channel.
        // It abstracts the operations that can be performed on a channel such as
        // declaring exchanges and queues, binding them, and publishing or consuming messages.
        AMQPChannel interface {
                // ExchangeDeclare declares an exchange on the channel.
                // The exchange will be created if it doesn't already exist.
                // Parameters:
                //   - name: The name of the exchange
                //   - kind: The exchange type (direct, fanout, topic, headers)
                //   - durable: Survive broker restarts
                //   - autoDelete: Delete when no longer used
                //   - internal: Can only be published to by other exchanges
                //   - noWait: Don't wait for a server confirmation
                //   - args: Additional arguments
                ExchangeDeclare(name, kind string, durable, autoDelete, internal, noWait bool, args amqp.Table) error

                // ExchangeBind binds an exchange to another exchange.
                // Parameters:
                //   - destination: The name of the destination exchange
                //   - key: The routing key to use
                //   - source: The name of the source exchange
                //   - noWait: Don't wait for a server confirmation
                //   - args: Additional arguments
                ExchangeBind(destination, key, source string, noWait bool, args amqp.Table) error

                // QueueDeclare declares a queue on the channel.
                // The queue will be created if it doesn't already exist.
                // Parameters:
                //   - name: The name of the queue
                //   - durable: Survive broker restarts
                //   - autoDelete: Delete when no longer used
                //   - exclusive: Used by only one connection and deleted when that connection closes
                //   - noWait: Don't wait for a server confirmation
                //   - args: Additional arguments
                // Returns the queue and any error encountered.
                QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args amqp.Table) (amqp.Queue, error)

                // QueueBind binds a queue to an exchange.
                // Parameters:
                //   - name: The name of the queue
                //   - key: The routing key to use
                //   - exchange: The name of the exchange
                //   - noWait: Don't wait for a server confirmation
                //   - args: Additional arguments
                QueueBind(name, key, exchange string, noWait bool, args amqp.Table) error

                // Consume starts delivering messages from a queue.
                // Parameters:
                //   - queue: The name of the queue
                //   - consumer: The consumer tag (empty string to have the server generate one)
                //   - autoAck: Acknowledge messages automatically when delivered
                //   - exclusive: Request exclusive consumer access
                //   - noLocal: Don't deliver messages published on this connection
                //   - noWait: Don't wait for a server confirmation
                //   - args: Additional arguments
                // Returns a channel of delivered messages and any error encountered.
                Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args amqp.Table) (&lt;-chan amqp.Delivery, error)

                // Publish publishes a message to an exchange.
                // Parameters:
                //   - exchange: The name of the exchange
                //   - key: The routing key to use
                //   - mandatory: Return message if it can't be routed to a queue
                //   - immediate: Return message if it can't be delivered to a consumer immediately
                //   - msg: The message to publish
                Publish(exchange, key string, mandatory, immediate bool, msg amqp.Publishing) error

                // IsClosed checks if the channel is closed.
                IsClosed() bool

                // Close closes the channel gracefully.
                Close() error

                // NotifyClose returns a channel that receives notifications when the channel is closed.
                // This is essential for connection management and automatic reconnection strategies.
                NotifyClose(receiver chan *amqp.Error) chan *amqp.Error

                // NotifyCancel returns a channel that receives notifications when a consumer is cancelled.
                // This helps detect when the server cancels consumers due to various conditions.
                NotifyCancel(receiver chan string) chan string
        }
)

// dial is a variable that holds the function to establish a connection to RabbitMQ.
// It allows for mocking in tests.
var dial = func(appName, connectionString string) (RMQConnection, error) <span class="cov0" title="0">{
        return amqp.DialConfig(connectionString, amqp.Config{
                Properties: amqp.Table{
                        "connection_name": appName,
                },
        })
}</span>

// NewConnection creates a new RabbitMQ connection and channel.
// It establishes a connection to the RabbitMQ server using the provided configuration,
// then creates a channel on that connection.
// Returns the connection, channel, and any error encountered.
func NewConnection(appName, connectionString string) (RMQConnection, AMQPChannel, error) <span class="cov0" title="0">{
        logrus.Debug("bunmq connecting to rabbitmq...")
        conn, err := dial(appName, connectionString)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("bunmq failure to connect to the broker")
                return nil, nil, rabbitMQDialError(err)
        }</span>
        <span class="cov0" title="0">logrus.Debug("bunmq connected to rabbitmq")

        logrus.Debug("bunmq creating amqp channel...")
        ch, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("bunmq failure to establish the channel")
                return nil, nil, getChannelError(err)
        }</span>
        <span class="cov0" title="0">logrus.Debug("bunmq created amqp channel")

        return conn, ch, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        "context"
        "sync"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/sirupsen/logrus"
)

type (
        // ConnectionManager manages RabbitMQ connections and channels with automatic reconnection
        // It monitors channel and connection health using NotifyClose and NotifyCancel
        ConnectionManager interface {
                // GetConnection returns the current connection, ensuring it's healthy
                GetConnection() (RMQConnection, error)

                // GetChannel returns the current channel, ensuring it's healthy
                GetChannel() (AMQPChannel, error)

                GetConnectionString() string

                // Close gracefully closes the connection manager
                Close() error

                // IsHealthy checks if both connection and channel are healthy
                IsHealthy() bool

                // SetReconnectCallback sets a callback function that's called when reconnection occurs
                SetReconnectCallback(callback func(conn RMQConnection, ch AMQPChannel))
        }

        // connectionManager implements ConnectionManager with automatic reconnection capabilities
        connectionManager struct {
                connectionString  string
                appName           string
                conn              RMQConnection
                ch                AMQPChannel
                mu                sync.RWMutex
                closed            bool
                reconnectCallback func(RMQConnection, AMQPChannel)

                // Reconnection configuration
                maxReconnectAttempts int
                reconnectDelay       time.Duration
                reconnectBackoffMax  time.Duration

                // Channels for monitoring connection/channel health
                connCloseNotify chan *amqp.Error
                chCloseNotify   chan *amqp.Error
                chCancelNotify  chan string

                // Context for cancellation
                ctx    context.Context
                cancel context.CancelFunc
        }

        // ReconnectionConfig holds configuration for reconnection behavior
        ReconnectionConfig struct {
                MaxAttempts   int           // Maximum reconnection attempts (0 = infinite)
                InitialDelay  time.Duration // Initial delay between reconnection attempts
                BackoffMax    time.Duration // Maximum delay between attempts
                BackoffFactor float64       // Exponential backoff factor
        }
)

// DefaultReconnectionConfig provides sensible defaults for reconnection behavior
var DefaultReconnectionConfig = ReconnectionConfig{
        MaxAttempts:   0,               // Infinite attempts
        InitialDelay:  time.Second * 2, // Start with 2 second delay
        BackoffMax:    time.Minute * 5, // Maximum 5 minute delay
        BackoffFactor: 1.5,             // 1.5x exponential backoff
}

// NewConnectionManager creates a new connection manager with automatic reconnection
func NewConnectionManager(appName, connectionString string, config ...ReconnectionConfig) (ConnectionManager, error) <span class="cov0" title="0">{
        cfg := DefaultReconnectionConfig
        if len(config) &gt; 0 </span><span class="cov0" title="0">{
                cfg = config[0]
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        cm := &amp;connectionManager{
                connectionString:     connectionString,
                appName:              appName,
                maxReconnectAttempts: cfg.MaxAttempts,
                reconnectDelay:       cfg.InitialDelay,
                reconnectBackoffMax:  cfg.BackoffMax,
                ctx:                  ctx,
                cancel:               cancel,
        }

        // Establish initial connection
        if err := cm.connect(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, err
        }</span>

        // Start monitoring goroutine
        <span class="cov0" title="0">go cm.monitor()

        return cm, nil</span>
}

// connect establishes connection and channel, setting up health monitoring
func (cm *connectionManager) connect() error <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        logrus.Info("bunmq establishing connection...")

        // Create connection
        conn, ch, err := NewConnection(cm.appName, cm.connectionString)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("bunmq failed to establish connection")
                return err
        }</span>

        // Set up notification channels for monitoring
        <span class="cov0" title="0">cm.setupNotificationChannels(conn, ch)

        cm.conn = conn
        cm.ch = ch

        logrus.Info("bunmq connection established successfully")

        // Call reconnect callback if set
        if cm.reconnectCallback != nil </span><span class="cov0" title="0">{
                cm.reconnectCallback(conn, ch)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupNotificationChannels configures NotifyClose and NotifyCancel monitoring
func (cm *connectionManager) setupNotificationChannels(conn RMQConnection, ch AMQPChannel) <span class="cov0" title="0">{
        // Monitor connection close events
        if amqpConn, ok := conn.(*amqp.Connection); ok </span><span class="cov0" title="0">{
                cm.connCloseNotify = make(chan *amqp.Error, 1)
                amqpConn.NotifyClose(cm.connCloseNotify)
        }</span>

        // Monitor channel close and cancel events
        <span class="cov0" title="0">if amqpCh, ok := ch.(*amqp.Channel); ok </span><span class="cov0" title="0">{
                cm.chCloseNotify = make(chan *amqp.Error, 1)
                cm.chCancelNotify = make(chan string, 1)

                amqpCh.NotifyClose(cm.chCloseNotify)
                amqpCh.NotifyCancel(cm.chCancelNotify)
        }</span>
}

// monitor runs in a goroutine to watch for connection/channel issues
func (cm *connectionManager) monitor() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cm.ctx.Done():<span class="cov0" title="0">
                        logrus.Info("bunmq connection manager stopped")
                        return</span>

                case err := &lt;-cm.connCloseNotify:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                logrus.WithError(err).Warn("bunmq connection closed unexpectedly")
                                cm.handleConnectionFailure()
                        }</span>

                case err := &lt;-cm.chCloseNotify:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                logrus.WithError(err).Warn("bunmq channel closed unexpectedly")
                                cm.handleChannelFailure()
                        }</span>

                case consumerTag := &lt;-cm.chCancelNotify:<span class="cov0" title="0">
                        logrus.WithField("consumerTag", consumerTag).Warn("bunmq consumer cancelled")
                        // For consumer cancellation, we typically want to recreate the channel
                        cm.handleChannelFailure()</span>
                }
        }
}

// handleChannelFailure attempts to recreate the channel while keeping the connection
func (cm *connectionManager) handleChannelFailure() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        if cm.closed </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logrus.Info("bunmq attempting to recreate channel...")

        // Check if connection is still healthy
        if cm.conn != nil &amp;&amp; !cm.conn.IsClosed() </span><span class="cov0" title="0">{
                // Try to create a new channel on the existing connection
                newCh, err := cm.conn.Channel()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("bunmq failed to recreate channel, will reconnect completely")
                        cm.handleConnectionFailure()
                        return
                }</span>

                // Set up monitoring for the new channel
                <span class="cov0" title="0">cm.setupChannelNotifications(newCh)
                cm.ch = newCh

                logrus.Info("bunmq channel recreated successfully")

                // Call reconnect callback if set
                if cm.reconnectCallback != nil </span><span class="cov0" title="0">{
                        cm.reconnectCallback(cm.conn, cm.ch)
                }</span>
        } else<span class="cov0" title="0"> {
                // Connection is also bad, do full reconnection
                cm.handleConnectionFailure()
        }</span>
}

// setupChannelNotifications sets up only channel-specific notifications
func (cm *connectionManager) setupChannelNotifications(ch *amqp.Channel) <span class="cov0" title="0">{
        cm.chCloseNotify = make(chan *amqp.Error, 1)
        cm.chCancelNotify = make(chan string, 1)

        ch.NotifyClose(cm.chCloseNotify)
        ch.NotifyCancel(cm.chCancelNotify)
}</span>

// handleConnectionFailure attempts full reconnection with exponential backoff
func (cm *connectionManager) handleConnectionFailure() <span class="cov0" title="0">{
        attempt := 0
        delay := cm.reconnectDelay

        cm.mu.Lock()
        cm.closed = true
        cm.mu.Unlock()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">attempt++

                // Check if we've exceeded max attempts
                if cm.maxReconnectAttempts &gt; 0 &amp;&amp; attempt &gt; cm.maxReconnectAttempts </span><span class="cov0" title="0">{
                        logrus.Errorf("bunmq exceeded maximum reconnection attempts (%d)", cm.maxReconnectAttempts)
                        return
                }</span>

                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "attempt": attempt,
                        "delay":   delay,
                }).Info("bunmq attempting reconnection...")

                // Wait before attempting reconnection
                select </span>{
                case &lt;-cm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                }

                // Attempt reconnection
                <span class="cov0" title="0">if err := cm.connect(); err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).WithField("attempt", attempt).Error("bunmq reconnection failed")

                        // Calculate next delay with exponential backoff
                        delay = min(time.Duration(float64(delay)*1.5), cm.reconnectBackoffMax)

                        continue</span>
                }

                <span class="cov0" title="0">cm.mu.Lock()
                cm.closed = false
                cm.mu.Unlock()

                logrus.WithField("attempt", attempt).Info("bunmq reconnection successful")
                return</span>
        }
}

func (cm *connectionManager) GetConnectionString() string <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        if cm.closed </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return cm.connectionString</span>
}

// GetConnection returns the current connection, ensuring it's healthy
func (cm *connectionManager) GetConnection() (RMQConnection, error) <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        if cm.closed </span><span class="cov0" title="0">{
                return nil, NewBunMQError("connection manager is closed")
        }</span>

        <span class="cov0" title="0">if cm.conn == nil || cm.conn.IsClosed() </span><span class="cov0" title="0">{
                return nil, NewBunMQError("connection is not available")
        }</span>

        <span class="cov0" title="0">return cm.conn, nil</span>
}

// GetChannel returns the current channel, ensuring it's healthy
func (cm *connectionManager) GetChannel() (AMQPChannel, error) <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        if cm.closed </span><span class="cov0" title="0">{
                return nil, NewBunMQError("connection manager is closed")
        }</span>

        <span class="cov0" title="0">if cm.ch == nil || cm.ch.IsClosed() </span><span class="cov0" title="0">{
                return nil, NewBunMQError("channel is not available")
        }</span>

        <span class="cov0" title="0">return cm.ch, nil</span>
}

// IsHealthy checks if both connection and channel are healthy
func (cm *connectionManager) IsHealthy() bool <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        if cm.closed </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return cm.conn != nil &amp;&amp; !cm.conn.IsClosed() &amp;&amp;
                cm.ch != nil &amp;&amp; !cm.ch.IsClosed()</span>
}

// SetReconnectCallback sets a callback function that's called when reconnection occurs
func (cm *connectionManager) SetReconnectCallback(callback func(conn RMQConnection, ch AMQPChannel)) <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.reconnectCallback = callback
}</span>

// Close gracefully closes the connection manager
func (cm *connectionManager) Close() error <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        if cm.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cm.closed = true
        cm.cancel()

        var err error
        if cm.ch != nil &amp;&amp; !cm.ch.IsClosed() </span><span class="cov0" title="0">{
                if closeErr := cm.ch.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logrus.WithError(closeErr).Error("bunmq error closing channel")
                        err = closeErr
                }</span>
        }

        <span class="cov0" title="0">if cm.conn != nil &amp;&amp; !cm.conn.IsClosed() </span><span class="cov0" title="0">{
                if closeErr := cm.conn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logrus.WithError(closeErr).Error("bunmq error closing connection")
                        err = closeErr
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("bunmq connection manager closed")
        return err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "os/signal"
        "reflect"
        "sync"
        "syscall"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/sirupsen/logrus"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

const (
        ConsumerDefinitionByType ConsumerDefinitionType = iota + 1
        ConsumerDefinitionByExchange
        ConsumerDefinitionByRoutingKey
        ConsumerDefinitionByExchangeRoutingKey
)

type (
        // Dispatcher defines an interface for managing RabbitMQ message consumption.
        // It provides methods to register message handlers and consume messages in a blocking manner.
        Dispatcher interface {
                // RegisterByType associates a queue with a message type and a handler function.
                // It ensures that messages from the specified queue are processed by the handler.
                // Returns an error if the registration parameters are invalid or if the queue definition is not found.
                RegisterByType(queue string, typE any, handler ConsumerHandler) error

                // RegisterByExchange associates a queue with a message handler based on the exchange.
                // It ensures that all messages from the specified exchange are processed by the handler.
                // Returns an error if the registration parameters are invalid or if the queue definition is not found.
                RegisterByExchange(queue string, msg any, exchange string, handler ConsumerHandler) error

                // RegisterByRoutingKey associates a queue with a message handler based on the routing key.
                // It ensures that all messages with the specified routing key are processed by the handler.
                // Returns an error if the registration parameters are invalid or if the queue definition is not found.
                RegisterByRoutingKey(queue string, msg any, routingKey string, handler ConsumerHandler) error

                // RegisterByExchangeRoutingKey associates a queue with a message handler based on both exchange and routing key.
                // It ensures that messages matching both the exchange and routing key are processed by the handler.
                // Returns an error if the registration parameters are invalid or if the queue definition is not found.
                RegisterByExchangeRoutingKey(queue string, msg any, exchange, routingKey string, handler ConsumerHandler) error

                // ConsumeBlocking starts consuming messages and dispatches them to the registered handlers.
                // This method blocks execution until the process is terminated by a signal.
                ConsumeBlocking()
        }

        ConsumerDefinitionType int

        // ConsumerHandler is a function type that defines message handler callbacks.
        // It receives a context (for tracing), the unmarshaled message, and metadata about the delivery.
        // Returns an error if the message processing fails.
        ConsumerHandler = func(ctx context.Context, msg any, metadata *DeliveryMetadata) error

        // ConsumerDefinition represents the configuration for a consumer.
        // It holds information about the queue, message type, and handler function.
        ConsumerDefinition struct {
                typ        ConsumerDefinitionType
                queue      string
                exchange   string
                routingKey string
                msgType    string
                reflect    *reflect.Value
                handler    ConsumerHandler
        }

        // deliveryMetadata contains metadata extracted from an AMQP delivery.
        // This includes message ID, retry count, message type, and headers.
        DeliveryMetadata struct {
                MessageID      string
                XCount         int64
                Type           string
                OriginExchange string
                RoutingKey     string
                Headers        map[string]interface{}
        }

        // dispatcher is the concrete implementation of the Dispatcher interface.
        // It manages the registration and execution of message handlers for RabbitMQ queues.
        dispatcher struct {
                manager             ConnectionManager
                queueDefinitions    map[string]*QueueDefinition
                consumersDefinition map[string][]*ConsumerDefinition
                tracer              trace.Tracer
                signalCh            chan os.Signal
                mu                  sync.RWMutex
                consuming           bool
                consumeChannels     map[string]&lt;-chan amqp.Delivery
        }
)

// NewDispatcher creates a new dispatcher instance with the provided configuration.
// It initializes signal handling and sets up the necessary components for message consumption.
func NewDispatcher(manager ConnectionManager, queueDefinitions []*QueueDefinition) Dispatcher <span class="cov0" title="0">{
        signalCh := make(chan os.Signal, 1)
        signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)

        customQueueDefs := make(map[string]*QueueDefinition)
        for _, q := range queueDefinitions </span><span class="cov0" title="0">{
                customQueueDefs[q.name] = q
        }</span>

        <span class="cov0" title="0">return &amp;dispatcher{
                manager:             manager,
                queueDefinitions:    customQueueDefs,
                consumersDefinition: map[string][]*ConsumerDefinition{},
                tracer:              otel.Tracer("bunmq-dispatcher"),
                signalCh:            signalCh,
                consumeChannels:     make(map[string]&lt;-chan amqp.Delivery),
        }</span>
}

// RegisterByType associates a queue with a message type and a handler function.
// It validates the parameters and ensures that the queue definition exists.
// Returns an error if the registration parameters are invalid or if the queue definition is not found.
func (d *dispatcher) RegisterByType(queue string, msg any, handler ConsumerHandler) error <span class="cov0" title="0">{
        if msg == nil || queue == "" </span><span class="cov0" title="0">{
                logrus.Error("bunmq invalid parameters to register consumer")
                return InvalidDispatchParamsError
        }</span>

        <span class="cov0" title="0">t := reflect.TypeOf(msg)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">ref := reflect.New(t)
        msgType := t.String()

        consumers := d.consumersDefinition[queue]
        for _, c := range consumers </span><span class="cov0" title="0">{
                if c.msgType == msgType </span><span class="cov0" title="0">{
                        logrus.Error("bunmq consumer already registered for this message")
                        return ConsumerAlreadyRegisteredForTheMessageError
                }</span>
        }

        <span class="cov0" title="0">_, ok := d.queueDefinitions[queue]
        if !ok </span><span class="cov0" title="0">{
                logrus.Error("bunmq queue definition not found for the given queue")
                return QueueDefinitionNotFoundError
        }</span>

        <span class="cov0" title="0">d.consumersDefinition[queue] = append(consumers, &amp;ConsumerDefinition{
                typ:     ConsumerDefinitionByType,
                queue:   queue,
                msgType: msgType,
                reflect: &amp;ref,
                handler: handler,
        })

        return nil</span>
}

// RegisterByExchange associates a queue with a message type and handler function based on the exchange.
func (d *dispatcher) RegisterByExchange(queue string, msg any, exchange string, handler ConsumerHandler) error <span class="cov0" title="0">{
        if msg == nil || queue == "" || exchange == "" </span><span class="cov0" title="0">{
                logrus.Error("bunmq invalid parameters to register consumer")
                return InvalidDispatchParamsError
        }</span>

        <span class="cov0" title="0">t := reflect.TypeOf(msg)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">ref := reflect.New(t)
        msgType := t.String()

        consumers := d.consumersDefinition[queue]
        for _, c := range consumers </span><span class="cov0" title="0">{
                if c.msgType == msgType </span><span class="cov0" title="0">{
                        logrus.Error("bunmq consumer already registered for this message")
                        return ConsumerAlreadyRegisteredForTheMessageError
                }</span>
        }

        <span class="cov0" title="0">_, ok := d.queueDefinitions[queue]
        if !ok </span><span class="cov0" title="0">{
                logrus.Error("bunmq queue definition not found for the given queue")
                return QueueDefinitionNotFoundError
        }</span>

        <span class="cov0" title="0">d.consumersDefinition[queue] = append(consumers, &amp;ConsumerDefinition{
                typ:      ConsumerDefinitionByExchange,
                queue:    queue,
                exchange: exchange,
                msgType:  msgType,
                reflect:  &amp;ref,
                handler:  handler,
        })

        return nil</span>
}

// RegisterByRoutingKey associates a queue with a message type and handler function based on the routing key.
func (d *dispatcher) RegisterByRoutingKey(queue string, msg any, routingKey string, handler ConsumerHandler) error <span class="cov0" title="0">{
        if msg == nil || queue == "" || routingKey == "" </span><span class="cov0" title="0">{
                logrus.Error("bunmq invalid parameters to register consumer")
                return InvalidDispatchParamsError
        }</span>

        <span class="cov0" title="0">t := reflect.TypeOf(msg)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">ref := reflect.New(t)
        msgType := t.String()

        consumers := d.consumersDefinition[queue]
        for _, c := range consumers </span><span class="cov0" title="0">{
                if c.msgType == msgType </span><span class="cov0" title="0">{
                        logrus.Error("bunmq consumer already registered for this message")
                        return ConsumerAlreadyRegisteredForTheMessageError
                }</span>
        }

        <span class="cov0" title="0">_, ok := d.queueDefinitions[queue]
        if !ok </span><span class="cov0" title="0">{
                logrus.Error("bunmq queue definition not found for the given queue")
                return QueueDefinitionNotFoundError
        }</span>

        <span class="cov0" title="0">d.consumersDefinition[queue] = append(consumers, &amp;ConsumerDefinition{
                typ:        ConsumerDefinitionByRoutingKey,
                queue:      queue,
                routingKey: routingKey,
                msgType:    msgType,
                reflect:    &amp;ref,
                handler:    handler,
        })

        return nil</span>
}

// RegisterByExchangeRoutingKey associates a queue with a message type and handler function based on both exchange and routing key.
func (d *dispatcher) RegisterByExchangeRoutingKey(queue string, msg any, exchange, routingKey string, handler ConsumerHandler) error <span class="cov0" title="0">{
        if msg == nil || queue == "" || exchange == "" || routingKey == "" </span><span class="cov0" title="0">{
                logrus.Error("bunmq invalid parameters to register consumer")
                return InvalidDispatchParamsError
        }</span>

        <span class="cov0" title="0">t := reflect.TypeOf(msg)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">ref := reflect.New(t)
        msgType := t.String()

        consumers := d.consumersDefinition[queue]
        for _, c := range consumers </span><span class="cov0" title="0">{
                if c.msgType == msgType </span><span class="cov0" title="0">{
                        logrus.Error("bunmq consumer already registered for this message")
                        return ConsumerAlreadyRegisteredForTheMessageError
                }</span>
        }

        <span class="cov0" title="0">_, ok := d.queueDefinitions[queue]
        if !ok </span><span class="cov0" title="0">{
                logrus.Error("bunmq queue definition not found for the given queue")
                return QueueDefinitionNotFoundError
        }</span>

        <span class="cov0" title="0">d.consumersDefinition[queue] = append(consumers, &amp;ConsumerDefinition{
                typ:        ConsumerDefinitionByExchangeRoutingKey,
                queue:      queue,
                exchange:   exchange,
                routingKey: routingKey,
                msgType:    msgType,
                reflect:    &amp;ref,
                handler:    handler,
        })

        return nil</span>
}

// ConsumeBlocking starts consuming messages from all registered queues.
// It creates a goroutine for each consumer and blocks until a termination signal is received.
// This method should be called after all Register operations are complete.
func (d *dispatcher) ConsumeBlocking() <span class="cov0" title="0">{
        d.mu.Lock()
        d.consuming = true
        d.mu.Unlock()

        logrus.Info("bunmq resilient dispatcher started, waiting for messages...")

        // Start all consumers
        for _, queueDef := range d.queueDefinitions </span><span class="cov0" title="0">{
                go d.consume(queueDef)
        }</span>

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-d.signalCh
        logrus.Info("bunmq signal received, closing resilient dispatcher")

        d.mu.Lock()
        d.consuming = false
        d.mu.Unlock()</span>
}

// consume starts consuming messages from a specific queue with automatic reconnection
func (d *dispatcher) consume(queueDef *QueueDefinition) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // Check if we should stop consuming
                d.mu.RLock()
                if !d.consuming </span><span class="cov0" title="0">{
                        d.mu.RUnlock()
                        return
                }</span>
                <span class="cov0" title="0">d.mu.RUnlock()

                // Get current channel from connection manager
                ch, err := d.manager.GetChannel()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failed to get channel for queue: %s, retrying...", queueDef.name)
                        time.Sleep(time.Second * 5)
                        continue</span>
                }

                // Start consuming from the queue
                <span class="cov0" title="0">delivery, err := ch.Consume(queueDef.name, "", false, false, false, false, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failure to declare consumer for queue: %s, retrying...", queueDef.name)
                        time.Sleep(time.Second * 5)
                        continue</span>
                }

                <span class="cov0" title="0">d.mu.Lock()
                d.consumeChannels[queueDef.name] = delivery
                d.mu.Unlock()

                logrus.Infof("bunmq started consuming from queue: %s", queueDef.name)

                // Process messages from this consumer
                for received := range delivery </span><span class="cov0" title="0">{
                        d.processReceivedMessage(queueDef, &amp;received)
                }</span>

                // If we reach here, the delivery channel was closed
                <span class="cov0" title="0">logrus.Warnf("bunmq delivery channel closed for queue: %s, will attempt to reconnect", queueDef.name)

                d.mu.Lock()
                delete(d.consumeChannels, queueDef.name)
                d.mu.Unlock()

                // Wait a bit before trying to reconnect
                logrus.Warnf("bunmq waiting before reconnecting for queue: %s", queueDef.name)
                time.Sleep(time.Second * 2)</span>
        }
}

// processReceivedMessage processes a received message from a specific queue.
func (d *dispatcher) processReceivedMessage(queueDef *QueueDefinition, received *amqp.Delivery) <span class="cov0" title="0">{
        metadata, err := d.extractMetadata(received)
        if err != nil </span><span class="cov0" title="0">{
                _ = received.Ack(false)
                return
        }</span>

        <span class="cov0" title="0">def, err := d.evaluateDefByReceivedMsg(queueDef, metadata)
        if err != nil </span><span class="cov0" title="0">{
                logrus.
                        WithField("messageID", metadata.MessageID).
                        Warnf("bunmq no consumer found for message type: %s", metadata.Type)
                _ = received.Ack(false)
                return
        }</span>

        <span class="cov0" title="0">logrus.
                WithField("messageID", metadata.MessageID).
                Debugf("bunmq received message: %s", metadata.Type)

        ctx, span := NewConsumerSpan(d.tracer, received.Headers, received.Type)

        ptr := def.reflect.Interface()
        if err = json.Unmarshal(received.Body, ptr); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                logrus.
                        WithContext(ctx).
                        WithError(err).
                        WithField("messageID", metadata.MessageID).
                        Errorf("bunmq unmarshal error: %s", received.Type)
                _ = received.Nack(true, false)
                span.End()
                return
        }</span>

        <span class="cov0" title="0">if queueDef.withRetry &amp;&amp; metadata.XCount &gt;= queueDef.retries </span><span class="cov0" title="0">{
                logrus.
                        WithContext(ctx).
                        WithField("messageID", metadata.MessageID).
                        Warnf("bunmq message reprocessed to many times, sending to dead letter")

                _ = received.Ack(false)

                if err = d.publishToDlq(ctx, queueDef, received); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        logrus.
                                WithContext(ctx).
                                WithError(err).
                                WithField("messageID", metadata.MessageID).
                                Error("bunmq failure to publish to dlq")
                }</span>

                <span class="cov0" title="0">span.End()
                return</span>
        }

        <span class="cov0" title="0">bunErr := def.handler(ctx, ptr, metadata)
        if bunErr != nil </span><span class="cov0" title="0">{
                logrus.
                        WithContext(ctx).
                        WithError(bunErr).
                        WithField("messageID", metadata.MessageID).
                        Error("bunmq error to process message")

                if queueDef.withRetry &amp;&amp; errors.Is(bunErr, RetryableError) </span><span class="cov0" title="0">{
                        logrus.
                                WithContext(ctx).
                                WithField("messageID", metadata.MessageID).
                                Warn("bunmq send message to process latter")

                        _ = received.Nack(false, false)
                        span.End()
                        return
                }</span>

                <span class="cov0" title="0">if queueDef.withDLQ </span><span class="cov0" title="0">{
                        span.RecordError(bunErr)
                        _ = received.Ack(false)

                        if err = d.publishToDlq(ctx, queueDef, received); err != nil </span><span class="cov0" title="0">{
                                span.RecordError(err)
                                logrus.
                                        WithContext(ctx).
                                        WithError(err).
                                        WithField("messageID", metadata.MessageID).
                                        Error("bunmq failure to publish to dlq")
                        }</span>

                        <span class="cov0" title="0">span.End()
                        return</span>
                }

                <span class="cov0" title="0">logrus.
                        WithContext(ctx).
                        WithError(bunErr).
                        WithField("messageID", metadata.MessageID).
                        Error("bunmq failure to process message, in queue without DLQ or retry, removing from queue")
                _ = received.Ack(false)</span>
        }

        <span class="cov0" title="0">logrus.
                WithContext(ctx).
                WithField("messageID", metadata.MessageID).
                Debug("bunmq message processed properly")
        _ = received.Ack(true)
        span.SetStatus(codes.Ok, "success")
        span.End()</span>
}

// extractMetadata extracts relevant metadata from an AMQP delivery.
// This includes the message ID, type, and retry count.
// Returns an error if the message has unformatted headers.
func (d *dispatcher) extractMetadata(delivery *amqp.Delivery) (*DeliveryMetadata, error) <span class="cov0" title="0">{
        msgType := delivery.Type
        exchange := delivery.Exchange
        routingKey := delivery.RoutingKey

        var xCount int64
        if xDeath, ok := delivery.Headers["x-death"]; ok </span><span class="cov0" title="0">{
                tables, _ := xDeath.([]any)

                lastTable, _ := tables[0].(amqp.Table)
                count, _ := lastTable["count"].(int64)
                xCount = count

                if len(tables) == 1 </span><span class="cov0" title="0">{
                        deathExchange, _ := lastTable["exchange"].(string)
                        exchange = deathExchange

                        if val, ok := lastTable["routing-keys"]; ok </span><span class="cov0" title="0">{
                                if keys, ok := val.([]any); ok &amp;&amp; len(keys) &gt; 0 </span><span class="cov0" title="0">{
                                        if key, ok := keys[0].(string); ok </span><span class="cov0" title="0">{
                                                routingKey = key
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        firstTable, _ := tables[len(tables)-1].(amqp.Table)
                        deathExchange, _ := firstTable["exchange"].(string)
                        exchange = deathExchange

                        if val, ok := firstTable["routing-keys"]; ok </span><span class="cov0" title="0">{
                                if keys, ok := val.([]any); ok &amp;&amp; len(keys) &gt; 0 </span><span class="cov0" title="0">{
                                        if key, ok := keys[0].(string); ok </span><span class="cov0" title="0">{
                                                routingKey = key
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return &amp;DeliveryMetadata{
                MessageID:      delivery.MessageId,
                Type:           msgType,
                XCount:         xCount,
                OriginExchange: exchange,
                RoutingKey:     routingKey,
                Headers:        delivery.Headers,
        }, nil</span>
}

func (d *dispatcher) evaluateDefByReceivedMsg(queueDef *QueueDefinition, metadata *DeliveryMetadata) (*ConsumerDefinition, error) <span class="cov0" title="0">{
        definitions, ok := d.consumersDefinition[queueDef.name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bunmq no consumer definitions found for queue: %s", queueDef.name)
        }</span>

        <span class="cov0" title="0">if len(definitions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bunmq no consumer definitions found for queue: %s", queueDef.name)
        }</span>

        <span class="cov0" title="0">for _, def := range definitions </span><span class="cov0" title="0">{
                switch def.typ </span>{
                case ConsumerDefinitionByType:<span class="cov0" title="0">
                        if def.msgType == metadata.Type </span><span class="cov0" title="0">{
                                return def, nil
                        }</span>
                case ConsumerDefinitionByExchangeRoutingKey:<span class="cov0" title="0">
                        if def.exchange == metadata.OriginExchange &amp;&amp; def.routingKey == metadata.RoutingKey </span><span class="cov0" title="0">{
                                return def, nil
                        }</span>
                case ConsumerDefinitionByExchange:<span class="cov0" title="0">
                        if def.exchange == metadata.OriginExchange </span><span class="cov0" title="0">{
                                return def, nil
                        }</span>
                case ConsumerDefinitionByRoutingKey:<span class="cov0" title="0">
                        if def.routingKey == metadata.RoutingKey </span><span class="cov0" title="0">{
                                return def, nil
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("bunmq unknown consumer definition type: %d", def.typ)</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("bunmq no consumer definition found for queue: %v", queueDef.name)</span>
}

// publishToDlq publishes a message to the dead-letter queue.
// It preserves the original message properties and headers.
func (d *dispatcher) publishToDlq(ctx context.Context, queueDef *QueueDefinition, received *amqp.Delivery) error <span class="cov0" title="0">{
        ch, err := d.manager.GetChannel()
        if err != nil </span><span class="cov0" title="0">{
                logrus.
                        WithContext(ctx).
                        WithError(err).
                        WithField("messageID", received.MessageId).
                        Error("bunmq failure to get channel for DLQ")
                return err
        }</span>

        <span class="cov0" title="0">return ch.Publish("", queueDef.dqlName, false, false, amqp.Publishing{
                Headers:     received.Headers,
                Type:        received.Type,
                ContentType: received.ContentType,
                MessageId:   received.MessageId,
                UserId:      received.UserId,
                AppId:       received.AppId,
                Body:        received.Body,
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

// RabbitMQError represents a custom error type for RabbitMQ-related operations.
// It encapsulates an error message describing the specific error condition.
type BunMQError struct {
        Message string
}

// NewBunMQError creates a new BunMQError instance with the provided message.
// Returns the error as an error interface.
func NewBunMQError(msg string) *BunMQError <span class="cov8" title="1">{
        return &amp;BunMQError{Message: msg}
}</span>

// Error implements the error interface and returns the error message.
func (e *BunMQError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

var (
        // rabbitMQDialError is a function that wraps a connection error into a BunMQError.
        rabbitMQDialError = func(err error) error <span class="cov8" title="1">{ return NewBunMQError(err.Error()) }</span>

        // getChannelError is a function that wraps a channel creation error into a BunMQError.
        getChannelError = func(err error) error <span class="cov8" title="1">{ return NewBunMQError(err.Error()) }</span>

        // NullableChannelError is returned when a channel operation is attempted on a nil channel.
        NullableChannelError = NewBunMQError("channel cant be null")

        // ConsumerAlreadyRegisteredError is returned when a consumer is already registered for a specific queue.
        ConsumerAlreadyRegisteredForTheMessageError = NewBunMQError("consumer already registered for the message")

        // NotFoundQueueDefinitionError is returned when a queue definition cannot be found.
        NotFoundQueueDefinitionError = NewBunMQError("not found queue definition")

        // InvalidDispatchParamsError is returned when invalid parameters are provided to a dispatch operation.
        InvalidDispatchParamsError = NewBunMQError("register dispatch with invalid parameters")

        // QueueDefinitionNotFoundError is returned when no queue definition is found for a specified queue.
        QueueDefinitionNotFoundError = NewBunMQError("any queue definition was founded to the given queue")

        // ReceivedMessageWithUnformattedHeaderError is returned when a message has incorrectly formatted headers.
        ReceivedMessageWithUnformattedHeaderError = NewBunMQError("received message with unformatted headers")

        // RetryableError indicates that a message processing failed but can be retried later.
        RetryableError = NewBunMQError("error to process this message, retry latter")
)
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

type (
        // ExchangeKind represents the type of a RabbitMQ exchange.
        // This type defines how messages are routed through the exchange.
        ExchangeKind string

        // ExchangeDefinition represents the configuration of a RabbitMQ exchange.
        // It encapsulates properties like name, durability, auto-delete behavior,
        // exchange type, and additional parameters.
        ExchangeDefinition struct {
                name    string
                durable bool
                delete  bool
                kind    ExchangeKind
                params  map[string]any
        }
)

// String returns the string representation of the ExchangeKind.
func (k ExchangeKind) String() string <span class="cov0" title="0">{
        return string(k)
}</span>

var (
        // FanoutExchange represents a fanout exchange type.
        // Fanout exchanges broadcast all messages to all bound queues.
        FanoutExchange ExchangeKind = "fanout"

        // DirectExchange represents a direct exchange type.
        // Direct exchanges route messages to queues based on a matching routing key.
        DirectExchange ExchangeKind = "direct"

        // TopicExchange represents a topic exchange type.
        // Topic exchanges route messages to queues based on wildcard matching of routing keys.
        // This allows for more complex routing patterns.
        TopicExchange ExchangeKind = "topic"

        // HeadersExchange represents a headers exchange type.
        // Headers exchanges route messages based on header attributes rather than routing keys.
        // This allows for routing based on multiple attributes.
        HeadersExchange ExchangeKind = "headers"

        // XDelayedMessageExchange represents a delayed message exchange type.
        // This exchange type allows messages to be delayed before being routed to queues.
        // It is used for implementing delayed message delivery patterns.
        //
        // Note: This exchange type requires the RabbitMQ Delayed Message Plugin.
        XDelayedMessageExchange ExchangeKind = "x-delayed-message"
)

// NewDirectExchange creates a new direct exchange definition with the given name.
// Direct exchanges route messages to queues based on exact matching of routing keys.
func NewDirectExchange(name string) *ExchangeDefinition <span class="cov0" title="0">{
        return defaultExchange(name, DirectExchange)
}</span>

// NewFanoutExchange creates a new fanout exchange definition with the given name.
// Fanout exchanges broadcast messages to all queues bound to them.
func NewFanoutExchange(name string) *ExchangeDefinition <span class="cov0" title="0">{
        return defaultExchange(name, FanoutExchange)
}</span>

// NewDirectExchanges creates multiple direct exchange definitions from a list of names.
// This is a convenience function for creating multiple direct exchanges at once.
func NewDirectExchanges(names []string) []*ExchangeDefinition <span class="cov0" title="0">{
        exchanges := []*ExchangeDefinition{}

        for _, name := range names </span><span class="cov0" title="0">{
                exchanges = append(exchanges, defaultExchange(name, DirectExchange))
        }</span>

        <span class="cov0" title="0">return exchanges</span>
}

// NewFanoutExchanges creates multiple fanout exchange definitions from a list of names.
// This is a convenience function for creating multiple fanout exchanges at once.
func NewFanoutExchanges(names []string) []*ExchangeDefinition <span class="cov0" title="0">{
        exchanges := []*ExchangeDefinition{}

        for _, name := range names </span><span class="cov0" title="0">{
                exchanges = append(exchanges, defaultExchange(name, FanoutExchange))
        }</span>

        <span class="cov0" title="0">return exchanges</span>
}

// defaultExchange creates a new exchange definition with default settings.
// By default, exchanges are durable and not auto-deleted.
func defaultExchange(name string, kind ExchangeKind) *ExchangeDefinition <span class="cov0" title="0">{
        return &amp;ExchangeDefinition{
                name:    name,
                durable: true,
                delete:  false,
                kind:    kind,
        }
}</span>

// Durable sets the durability flag for the exchange.
// Durable exchanges survive broker restarts.
func (e *ExchangeDefinition) Durable(d bool) *ExchangeDefinition <span class="cov0" title="0">{
        e.durable = d
        return e
}</span>

// Delete sets the auto-delete flag for the exchange.
// Auto-deleted exchanges are removed when no longer in use.
func (e *ExchangeDefinition) Delete(d bool) *ExchangeDefinition <span class="cov0" title="0">{
        e.delete = d
        return e
}</span>

// Params sets additional parameters for the exchange.
// These are passed as arguments when declaring the exchange.
func (e *ExchangeDefinition) Params(p map[string]any) *ExchangeDefinition <span class="cov0" title="0">{
        e.params = p
        return e
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "time"

        "github.com/google/uuid"
        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/sirupsen/logrus"
)

type (
        // Publisher defines an interface for publishing messages to a messaging system.
        // It provides methods for sending messages with optional metadata such as
        // destination, source, and routing keys.
        Publisher interface {
                // Publish sends a message to the specified destination.
                //
                // Parameters:
                // - ctx: The context for managing deadlines, cancellations, and other request-scoped values.
                // - exchange: The destination or topic where the message should be sent.
                // - routingKey: A routing key or identifier for the message (optional).
                // - msg: The message payload to be sent.
                // - options: Additional dynamic parameters for the message (optional).
                //
                // Returns:
                // - An error if the message could not be sent.
                Publish(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error

                // PublishDeadline sends a message to the specified destination with a deadline.
                // This method ensures that the message is sent within the context's deadline.
                //
                // Parameters:
                // - ctx: The context for managing deadlines, cancellations, and other request-scoped values.
                // - exchange: The destination or topic where the message should be sent.
                // - routingKey: A routing key or identifier for the message (optional).
                // - msg: The message payload to be sent.
                // - options: Additional dynamic parameters for the message (optional).
                //
                // Returns:
                // - An error if the message could not be sent within the deadline.
                PublishDeadline(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error

                PublishQueue(ctx context.Context, queue string, msg any, options ...*Option) error
                PublishQueueDeadline(ctx context.Context, queue string, msg any, options ...*Option) error
        }

        // publisher is the concrete implementation of the Publisher interface.
        // It handles the details of marshaling messages, setting headers, and publishing to RabbitMQ.
        publisher struct {
                appName string
                manager ConnectionManager
        }
)

// JsonContentType is the MIME type used for JSON message content.
const (
        JsonContentType = "application/json"
)

// NewPublisher creates a new publisher instance with the provided configuration and AMQP channel.
func NewPublisher(appName string, manager ConnectionManager) Publisher <span class="cov0" title="0">{
        return &amp;publisher{appName, manager}
}</span>

// SimplePublish publishes a message directly to a target queue.
// The exchange is left empty, which means the default exchange is used.
func (p *publisher) SimplePublish(ctx context.Context, target string, msg any) error <span class="cov0" title="0">{
        return p.publish(ctx, target, "", msg)
}</span>

// Publish publishes a message to a specified exchange with optional routing key.
// It aligns with the Publisher interface and handles tracing propagation.
// Parameters:
//   - ctx: Context for tracing and cancellation
//   - to: Pointer to the target exchange name (required)
//   - from: Pointer to source identifier (optional, not used)
//   - key: Pointer to routing key (optional)
//   - msg: The message to publish (will be marshaled to JSON)
//   - options: Additional publishing options (optional)
//
// Returns an error if publishing fails or if the exchange name is empty.
func (p *publisher) Publish(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error <span class="cov0" title="0">{
        if exchange == "" </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).Error("exchange cannot be empty")
                return fmt.Errorf("exchange cannot be empty")
        }</span>

        <span class="cov0" title="0">return p.publish(ctx, exchange, routingKey, msg)</span>
}

// PublishDeadline publishes a message to a specified exchange with a deadline.
// It's similar to Publish but with an added timeout of 1 second.
// Parameters:
//   - ctx: Context for tracing and cancellation
//   - to: Pointer to the target exchange name (required)
//   - from: Pointer to source identifier (optional, not used)
//   - key: Pointer to routing key (optional)
//   - msg: The message to publish (will be marshaled to JSON)
//   - options: Additional publishing options (optional)
//
// Returns an error if publishing fails, times out, or if the exchange name is empty.
func (p *publisher) PublishDeadline(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error <span class="cov0" title="0">{
        if exchange == "" </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).Error("exchange cannot be empty")
                return fmt.Errorf("exchange cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, time.Second)
        defer cancel()

        return p.publish(ctx, exchange, routingKey, msg)</span>
}

func (p *publisher) PublishQueue(ctx context.Context, queue string, msg any, options ...*Option) error <span class="cov0" title="0">{
        if queue == "" </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).Error("queue cannot be empty")
                return fmt.Errorf("queue cannot be empty")
        }</span>

        <span class="cov0" title="0">return p.publish(ctx, "", queue, msg)</span>
}

func (p *publisher) PublishQueueDeadline(ctx context.Context, queue string, msg any, options ...*Option) error <span class="cov0" title="0">{
        if queue == "" </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).Error("queue cannot be empty")
                return fmt.Errorf("queue cannot be empty")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, time.Second)
        defer cancel()

        return p.publish(ctx, "", queue, msg)</span>
}

// publish is the internal method that handles the details of publishing a message.
// It marshals the message to JSON, sets headers for tracing, and publishes to RabbitMQ.
func (p *publisher) publish(ctx context.Context, exchange, key string, msg any) error <span class="cov0" title="0">{
        ch, err := p.manager.GetChannel()
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).WithError(err).Error("publisher get channel")
                return err
        }</span>

        <span class="cov0" title="0">byt, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithContext(ctx).WithError(err).Error("publisher marshal")
                return err
        }</span>

        <span class="cov0" title="0">headers := amqp.Table{}
        AMQPPropagator.Inject(ctx, AMQPHeader(headers))

        mID, err := uuid.NewV7()
        if err != nil </span><span class="cov0" title="0">{
                mID = uuid.New()
        }</span>

        <span class="cov0" title="0">t := reflect.TypeOf(msg)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov0" title="0">msgType := t.Name()
        if msgType == "" </span><span class="cov0" title="0">{
                msgType = t.String()
        }</span>

        <span class="cov0" title="0">return ch.Publish(exchange, key, false, false, amqp.Publishing{
                Headers:     headers,
                Type:        msgType,
                ContentType: JsonContentType,
                MessageId:   mID.String(),
                AppId:       p.appName,
                Body:        byt,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        "fmt"
        "time"
)

// QueueDefinition represents the configuration of a RabbitMQ queue.
// It encapsulates properties such as name, durability, auto-delete behavior,
// exclusivity, TTL, DLQ (Dead Letter Queue), and retry mechanisms.
type QueueDefinition struct {
        name             string
        durable          bool
        delete           bool
        exclusive        bool
        withTTL          bool
        ttl              time.Duration
        withMaxLength    bool
        maxLength        int64
        withDLQ          bool
        dqlName          string
        withDLQMaxLength bool
        dlqMaxLength     int64
        withRetry        bool
        retryTTL         time.Duration
        retries          int64
}

// NewQueue creates a new queue definition with the given name.
// By default, queues are durable, not auto-deleted, and not exclusive.
// You can chain methods to configure additional properties such as TTL, DLQ, and retry behavior.
//
// Example usage:
//
//         queueDef := bunmq.NewQueue("my-queue").Durable(true).WithRetry(time.Second*10, 3).WithDQL()
//
//        This creates a durable queue with retry and dead letter queue enabled.
//
// Note: The queue name must be unique within the RabbitMQ broker.
// It is used to declare the queue and bind it to exchanges.
// If the queue already exists with different properties, an error will be returned when trying to declare
func NewQueue(name string) *QueueDefinition <span class="cov8" title="1">{
        return &amp;QueueDefinition{name: name, durable: true, delete: false, exclusive: false}
}</span>

// Durable sets the durability flag for the queue.
// Durable queues survive broker restarts.
func (q *QueueDefinition) Durable(d bool) *QueueDefinition <span class="cov8" title="1">{
        q.durable = d
        return q
}</span>

// Delete sets the auto-delete flag for the queue.
// Auto-deleted queues are removed when no longer in use.
func (q *QueueDefinition) Delete(d bool) *QueueDefinition <span class="cov8" title="1">{
        q.delete = d
        return q
}</span>

// Exclusive sets the exclusive flag for the queue.
// Exclusive queues can only be used by the connection that created them
// and are deleted when that connection closes.
func (q *QueueDefinition) Exclusive(e bool) *QueueDefinition <span class="cov8" title="1">{
        q.exclusive = e
        return q
}</span>

// WithMaxLength sets a maximum length for the queue.
func (q *QueueDefinition) WithMaxLength(length int64) *QueueDefinition <span class="cov8" title="1">{
        q.withMaxLength = true
        q.maxLength = length
        return q
}</span>

// WithTTL sets a Time-To-Live (TTL) for messages in the queue.
// Messages that remain in the queue longer than the TTL will be automatically removed.
func (q *QueueDefinition) WithTTL(ttl time.Duration) *QueueDefinition <span class="cov8" title="1">{
        q.withTTL = true
        q.ttl = ttl
        return q
}</span>

// WithDQL enables a Dead Letter Queue (DLQ) for this queue.
// Messages that are rejected, expired, or exceed max length will be routed to the DLQ.
// The DLQ name is automatically generated as "&lt;queue-name&gt;-dlq".
func (q *QueueDefinition) WithDQL() *QueueDefinition <span class="cov8" title="1">{
        q.withDLQ = true
        q.dqlName = fmt.Sprintf("%s-dlq", q.name)
        return q
}</span>

// WithDLQMaxLength sets a maximum length for the Dead Letter Queue.
func (q *QueueDefinition) WithDLQMaxLength(length int64) *QueueDefinition <span class="cov8" title="1">{
        q.withDLQMaxLength = true
        q.dlqMaxLength = length
        return q
}</span>

// WithRetry enables a retry mechanism for this queue.
// Failed messages will be moved to a retry queue for the specified TTL duration
// and then requeued up to the specified number of retries.
func (q *QueueDefinition) WithRetry(ttl time.Duration, retries int64) *QueueDefinition <span class="cov8" title="1">{
        q.withRetry = true
        q.retryTTL = ttl
        q.retries = retries
        return q
}</span>

// Name returns the name of the queue.
// This is the identifier used to declare and bind the queue in RabbitMQ.
// It is also used to create the DLQ and retry queue names.
func (q *QueueDefinition) Name() string <span class="cov8" title="1">{
        return q.name
}</span>

// DLQName returns the name of the Dead Letter Queue associated with this queue.
// The DLQ name follows the pattern "&lt;queue-name&gt;-dlq".
func (q *QueueDefinition) DLQName() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-dlq", q.name)
}</span>

// RetryName returns the name of the Retry Queue associated with this queue.
// The Retry Queue name follows the pattern "&lt;queue-name&gt;-retry".
func (q *QueueDefinition) RetryName() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-retry", q.name)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2025, The GoKit Authors
// MIT License
// All rights reserved.

package bunmq

import (
        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/sirupsen/logrus"
)

type (
        // Topology defines the interface for managing RabbitMQ topology components.
        // Topology includes the configuration of exchanges, queues, and their bindings.
        // It provides methods to declare and apply a complete messaging topology.
        Topology interface {
                // Queue adds a queue definition to the topology.
                Queue(q *QueueDefinition) Topology

                // Queues adds multiple queue definitions to the topology.
                Queues(queues []*QueueDefinition) Topology

                // Exchange adds an exchange definition to the topology.
                Exchange(e *ExchangeDefinition) Topology

                // Exchanges adds multiple exchange definitions to the topology.
                Exchanges(e []*ExchangeDefinition) Topology

                // ExchangeBinding adds an exchange-to-exchange binding to the topology.
                ExchangeBinding(b *ExchangeBindingDefinition) Topology

                // QueueBinding adds an exchange-to-queue binding to the topology.
                QueueBinding(b *QueueBindingDefinition) Topology

                // GetQueuesDefinition returns all queue definitions in the topology.
                GetQueuesDefinition() map[string]*QueueDefinition

                // GetQueueDefinition retrieves a queue definition by name.
                // Returns an error if the queue definition doesn't exist.
                GetQueueDefinition(queueName string) (*QueueDefinition, error)

                // Apply declares all the exchanges, queues, and bindings defined in the topology.
                // Returns an error if any part of the topology cannot be applied.
                Apply() (ConnectionManager, error)
        }

        // topology is the concrete implementation of the Topology interface.
        // It maintains collections of exchanges, queues, and their bindings,
        // and provides methods to declare and apply them to a RabbitMQ broker.
        topology struct {
                connectionString  string
                appName           string
                channel           AMQPChannel
                queues            map[string]*QueueDefinition
                queuesBinding     []*QueueBindingDefinition
                exchanges         []*ExchangeDefinition
                exchangesBinding  []*ExchangeBindingDefinition
                connectionManager ConnectionManager
        }
)

// NewTopology creates a new topology instance with the provided configuration.
// It initializes empty collections for queues and queue bindings.
func NewTopology(appName, connectionString string) Topology <span class="cov0" title="0">{
        return &amp;topology{
                connectionString: connectionString,
                appName:          appName,
                queues:           map[string]*QueueDefinition{},
                queuesBinding:    []*QueueBindingDefinition{},
                exchanges:        []*ExchangeDefinition{},
                exchangesBinding: []*ExchangeBindingDefinition{},
        }
}</span>

// Queue adds a queue definition to the topology.
// The queue is indexed by its name for easy retrieval.
func (t *topology) Queue(q *QueueDefinition) Topology <span class="cov0" title="0">{
        t.queues[q.name] = q
        return t
}</span>

// Queues adds multiple queue definitions to the topology.
// Each queue is indexed by its name for easy retrieval.
func (t *topology) Queues(queues []*QueueDefinition) Topology <span class="cov0" title="0">{
        for _, q := range queues </span><span class="cov0" title="0">{
                t.queues[q.name] = q
        }</span>

        <span class="cov0" title="0">return t</span>
}

// GetQueuesDefinition returns all queue definitions in the topology.
func (t *topology) GetQueuesDefinition() map[string]*QueueDefinition <span class="cov0" title="0">{
        return t.queues
}</span>

// GetQueueDefinition retrieves a queue definition by name.
// Returns an error if the queue definition doesn't exist.
func (t *topology) GetQueueDefinition(queueName string) (*QueueDefinition, error) <span class="cov0" title="0">{
        if d, ok := t.queues[queueName]; ok </span><span class="cov0" title="0">{
                return d, nil
        }</span>

        <span class="cov0" title="0">return nil, NotFoundQueueDefinitionError</span>
}

// Exchange adds an exchange definition to the topology.
func (t *topology) Exchange(e *ExchangeDefinition) Topology <span class="cov0" title="0">{
        t.exchanges = append(t.exchanges, e)
        return t
}</span>

// Exchanges adds multiple exchange definitions to the topology.
func (t *topology) Exchanges(e []*ExchangeDefinition) Topology <span class="cov0" title="0">{
        t.exchanges = append(t.exchanges, e...)
        return t
}</span>

// ExchangeBinding adds an exchange-to-exchange binding to the topology.
func (t *topology) ExchangeBinding(b *ExchangeBindingDefinition) Topology <span class="cov0" title="0">{
        t.exchangesBinding = append(t.exchangesBinding, b)
        return t
}</span>

// QueueBinding adds an exchange-to-queue binding to the topology.
// The binding is indexed by the queue name.
func (t *topology) QueueBinding(b *QueueBindingDefinition) Topology <span class="cov0" title="0">{
        t.queuesBinding = append(t.queuesBinding, b)
        return t
}</span>

// Apply declares all the exchanges, queues, and bindings defined in the topology.
// It follows a specific order to ensure proper dependency resolution:
//  1. Exchanges are declared first
//  2. Queues are declared next (including any associated retry or DLQ queues)
//  3. Queues are bound to exchanges
//  4. Exchanges are bound to other exchanges
//
// This ordering ensures that all required resources exist before binding them together.
// When declaring queues, any retry queues and dead-letter queues specified in the queue
// definitions are automatically created with appropriate arguments for message routing.
//
// Returns the connection, channel and an error if any part of the topology cannot be applied.
// Common error cases include:
//   - Channel is nil (NullableChannelError)
//   - Exchange declaration failure (permission issues, invalid arguments)
//   - Queue declaration failure (permission issues, invalid arguments)
//   - Binding failure (non-existent queues or exchanges)
func (t *topology) Apply() (ConnectionManager, error) <span class="cov0" title="0">{
        manager, err := NewConnectionManager(t.appName, t.connectionString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">t.connectionManager = manager

        ch, err := manager.GetChannel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">t.channel = ch

        if err := t.declareExchanges(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := t.declareQueues(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := t.bindQueues(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := t.bindExchanges(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return t.connectionManager, nil</span>
}

// declareExchanges declares all the exchanges defined in the topology.
func (t *topology) declareExchanges() error <span class="cov0" title="0">{
        logrus.Info("bunmq declaring exchanges...")

        for _, exch := range t.exchanges </span><span class="cov0" title="0">{
                if err := t.channel.ExchangeDeclare(exch.name, exch.kind.String(), exch.durable, exch.delete, false, false, exch.params); err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failure to declare exchange: %s", exch.name)
                        return err
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("bunmq exchanges declared")

        return nil</span>
}

// declareQueues declares all the queues defined in the topology.
// For each queue, it also declares any associated retry or dead letter queues
// as defined in the queue properties.
func (t *topology) declareQueues() error <span class="cov0" title="0">{
        logrus.Info("bunmq declaring queues...")

        for _, queue := range t.queues </span><span class="cov0" title="0">{
                logrus.Infof("bunmq declaring queue: %s ...", queue.name)

                if queue.withRetry </span><span class="cov0" title="0">{
                        logrus.Infof("bunmq declaring retry queue: %s ...", queue.RetryName())

                        //queue.RetryName(), true, false, false, false, amqpDlqDeclarationOpts
                        if _, err := t.channel.QueueDeclare(queue.RetryName(), queue.durable, queue.delete, queue.exclusive, false, amqp.Table{
                                "x-dead-letter-exchange":    "",
                                "x-dead-letter-routing-key": queue.name,
                                "x-message-ttl":             queue.retryTTL.Milliseconds(),
                                "x-retry-count":             queue.retries,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">logrus.Info("bunmq retry queue declared")</span>
                }

                <span class="cov0" title="0">var amqpDlqDeclarationOpts amqp.Table
                if queue.withDLQ &amp;&amp; queue.withRetry </span><span class="cov0" title="0">{
                        amqpDlqDeclarationOpts = amqp.Table{
                                "x-dead-letter-exchange":    "",
                                "x-dead-letter-routing-key": queue.RetryName(),
                        }
                }</span>

                <span class="cov0" title="0">if queue.withDLQ &amp;&amp; !queue.withRetry </span><span class="cov0" title="0">{
                        amqpDlqDeclarationOpts = amqp.Table{
                                "x-dead-letter-exchange":    "",
                                "x-dead-letter-routing-key": queue.DLQName(),
                        }
                }</span>

                <span class="cov0" title="0">if queue.withDLQMaxLength </span><span class="cov0" title="0">{
                        amqpDlqDeclarationOpts["x-max-length"] = queue.dlqMaxLength
                }</span>

                <span class="cov0" title="0">if queue.withDLQ </span><span class="cov0" title="0">{
                        logrus.Infof("bunmq declaring dlq queue: %s ...", queue.DLQName())

                        //queue.DLQName(), true, false, false, false, amqpDlqDeclarationOpts
                        if _, err := t.channel.QueueDeclare(queue.DLQName(), queue.durable, queue.delete, queue.exclusive, false, amqpDlqDeclarationOpts); err != nil </span><span class="cov0" title="0">{
                                logrus.WithError(err).Errorf("bunmq failure to declare dlq queue: %s", queue.DLQName())
                                return err
                        }</span>

                        <span class="cov0" title="0">delete(amqpDlqDeclarationOpts, "x-max-length")
                        logrus.Info("bunmq dlq queue declared")</span>
                }

                <span class="cov0" title="0">if queue.withMaxLength </span><span class="cov0" title="0">{
                        amqpDlqDeclarationOpts["x-max-length"] = queue.maxLength
                }</span>

                <span class="cov0" title="0">if _, err := t.channel.QueueDeclare(queue.name, queue.durable, queue.delete, queue.exclusive, false, amqpDlqDeclarationOpts); err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failure to declare queue: %s", queue.name)
                        return err
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("bunmq queues declared")
        return nil</span>
}

// bindQueues binds all the queues to their respective exchanges
// according to the queue bindings defined in the topology.
func (t *topology) bindQueues() error <span class="cov0" title="0">{
        logrus.Info("bunmq binding queues...")

        for _, bind := range t.queuesBinding </span><span class="cov0" title="0">{
                if err := t.channel.QueueBind(bind.queue, bind.routingKey, bind.exchange, false, bind.args); err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failure to bind queue: %s to exchange: %s", bind.queue, bind.exchange)
                        return err
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("bunmq queues bonded")

        return nil</span>
}

// bindExchanges binds exchanges to each other according to
// the exchange bindings defined in the topology.
func (t *topology) bindExchanges() error <span class="cov0" title="0">{
        logrus.Info("bunmq binding exchanges...")

        for _, bind := range t.exchangesBinding </span><span class="cov0" title="0">{
                if err := t.channel.ExchangeBind(bind.destination, bind.routingKey, bind.source, false, bind.args); err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("bunmq failure to bind exchange: %s to %s", bind.destination, bind.source)
                        return err
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("bunmq exchanges bonded")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2025 The GoKit Authors
// MIT License
// All rights reserved.

// Package amqp provides utilities for propagating trace context through AMQP (Advanced Message
// Queuing Protocol) messages. This enables distributed tracing across message-based
// microservices, allowing observability of end-to-end transactions across
// synchronous HTTP calls and asynchronous messaging.
//
// The package implements OpenTelemetry's TextMapCarrier interface for AMQP headers
// and provides functions to extract and inject trace context from/to AMQP messages.
package bunmq

import (
        "context"
        "fmt"
        "sort"
        "strings"

        amqp "github.com/rabbitmq/amqp091-go"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
)

// Traceparent represents the components of a trace context that are propagated between services.
// It contains the identifiers and flags needed to correlate spans across service boundaries
// when using message queuing.
type Traceparent struct {
        // TraceID is the globally unique identifier for a trace
        TraceID trace.TraceID

        // SpanID is the identifier for a specific operation within a trace
        SpanID trace.SpanID

        // TraceFlags contain options such as the sampling decision
        TraceFlags trace.TraceFlags
}

var (
        // AMQPPropagator is a composite propagator that combines TraceContext and Baggage propagation
        // for AMQP messaging contexts. This enables both trace correlation and contextual properties
        // to be passed between services.
        AMQPPropagator = propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
)

// AMQPHeader wraps amqp.Table to implement the TextMapCarrier interface for OpenTelemetry propagation.
// This allows trace context to be injected into and extracted from AMQP message headers.
type AMQPHeader amqp.Table

// Set sets the value for the given key in the AMQP header (case-insensitive).
// This implements part of the TextMapCarrier interface required by OpenTelemetry
// for context propagation.
//
// Parameters:
//   - key: The header key (will be converted to lowercase)
//   - val: The header value to set
func (h AMQPHeader) Set(key, val string) <span class="cov0" title="0">{
        key = strings.ToLower(key)

        h[key] = val
}</span>

// Get retrieves the value for a given key from the AMQP header (case-insensitive).
// This implements part of the TextMapCarrier interface required by OpenTelemetry
// for context propagation.
//
// Parameters:
//   - key: The header key to retrieve (will be converted to lowercase)
//
// Returns:
//   - string: The header value, or empty string if not found or not a string
func (h AMQPHeader) Get(key string) string <span class="cov0" title="0">{
        key = strings.ToLower(key)

        value, ok := h[key]

        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">toString, ok := value.(string)

        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return toString</span>
}

// Keys returns a sorted list of all keys in the AMQP header.
// This implements part of the TextMapCarrier interface required by OpenTelemetry
// for context propagation.
//
// Returns:
//   - []string: A sorted slice of all header keys
func (h AMQPHeader) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(h))

        for k := range h </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>

        <span class="cov0" title="0">sort.Strings(keys)

        return keys</span>
}

// NewConsumerSpan creates a new span for AMQP message consumption with the trace context
// extracted from the message headers. This allows continuation of a trace that was
// started in a producer service, maintaining the end-to-end transaction context.
//
// Parameters:
//   - tracer: The OpenTelemetry tracer to create the span
//   - header: The AMQP message headers containing the trace context
//   - typ: The type of consumer, used to name the span (e.g., queue name)
//
// Returns:
//   - context.Context: Context with the extracted trace information
//   - trace.Span: The new span created for this consumer operation
func NewConsumerSpan(tracer trace.Tracer, header amqp.Table, typ string) (context.Context, trace.Span) <span class="cov0" title="0">{
        ctx := AMQPPropagator.Extract(context.Background(), AMQPHeader(header))
        return tracer.Start(ctx, fmt.Sprintf("consume.%s", typ))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
