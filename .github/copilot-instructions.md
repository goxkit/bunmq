# GitHub Copilot Instructions

This repository uses a structured, multi-file instruction system to guide GitHub Copilot's code generation behavior. These instructions enforce deterministic, production-grade engineering practices across the entire codebase.

## Instruction System Overview

This instruction system is organized into focused, single-responsibility files:

- **Repository-wide rules** (this file): Global principles, architecture overview, and system organization
- **Path-specific instructions** (`.github/instructions/`): Targeted rules for specific file types and directories

### Instruction File Structure

```
.github/
├── copilot-instructions.md                    # Main entry point (this file)
└── instructions/
    ├── project-structure.instructions.md      # Directory structure, file organization
    ├── architecture.instructions.md          # SOLID principles, clean architecture, patterns
    ├── golang.instructions.md                # Go-specific rules, idioms, mandatory tooling
    ├── coding-conventions.instructions.md   # Naming, formatting, code style
    ├── observability.instructions.md        # Logging, tracing, OpenTelemetry
    ├── security.instructions.md              # Security practices, vulnerability prevention
    ├── testing.instructions.md               # Testing patterns, coverage, mocks
    └── ai-behavior.instructions.md          # AI-specific directives and constraints
```

Each instruction file:
- Uses YAML frontmatter with `applyTo` for path-specific targeting
- Follows strict rule format: Description, When it applies, Copilot MUST/MUST NOT, Examples
- References real codebase files using `@path/to/file.go` syntax
- Contains actionable, enforceable directives (not suggestions)

## Core Engineering Principles

All code generated by Copilot MUST follow these non-negotiable principles:

### 1. SOLID Principles

- **Single Responsibility**: Each file, struct, and function has ONE clear purpose
- **Dependency Inversion**: Depend on interfaces, not concrete implementations
- **No God Objects**: Prohibit god services, god structs, or mixed responsibilities
- **Interface Segregation**: Keep interfaces small and focused

### 2. Clean Code

- **Small Functions**: Functions under 30 lines (excluding comments)
- **Meaningful Names**: Descriptive, intention-revealing names
- **Clear Separation**: Distinct boundaries between layers
- **No Magic Values**: Use constants for semantic values
- **Early Returns**: Use guard clauses, avoid deep nesting

### 3. 12-Factor App

- **Configuration**: Load from environment variables only
- **Stateless**: Services must be stateless
- **Logs**: Treat as event streams (stdout/stderr)
- **Backing Services**: Explicit dependencies (databases, queues, caches)

### 4. Observability (MANDATORY)

- **Structured Logging**: Use Logrus with fields, never string concatenation
- **Log Levels**: Debug, Info, Warn, Error (use appropriately)
- **Context Propagation**: Always propagate `context.Context`
- **Tracing**: Use OpenTelemetry for significant operations
- **No Secrets**: Never log passwords, tokens, or sensitive data

### 5. Cloud-Native Design

- **Container-First**: Assume containerized deployment
- **Graceful Shutdown**: Handle SIGTERM properly
- **Health Checks**: Implement readiness and liveness endpoints
- **Kubernetes-Ready**: Compatible with K8s patterns

## Quality Gates (MANDATORY)

All code MUST pass these tools without warnings:

1. **golangci-lint**: Zero warnings
2. **go vet**: No issues
3. **gosec**: No security vulnerabilities
4. **go test**: All tests passing
5. **gofmt**: Properly formatted

## Project Structure

This is a Go microservice (`go-clearing-mc-inc-ms`) that:

- Processes Mastercard clearing incoming files (T112, MPE, etc.)
- Handles multiple file types (incoming, full_mpe, incremental_mpe, reports)
- Uses RabbitMQ for message consumption
- Implements multi-tenant database support
- Follows clean architecture with dependency injection
- Uses OpenTelemetry for observability

### Directory Structure

```
go-clearing-mc-inc-ms/
├── cmd/                    # Application entry points
│   ├── cmd.go             # Cobra command definition
│   └── container.go       # Dependency injection container
├── internal/               # Private application code
│   ├── interfaces/        # Service and repository contracts
│   │   ├── repositories/  # Repository interfaces
│   │   └── services/      # Service interfaces
│   ├── repositories/      # Data access layer implementations
│   ├── services/          # Business logic layer
│   │   ├── incoming/      # T112 incoming file processing
│   │   ├── full_mpe/      # Full MPE processing
│   │   ├── incremental_mpe/ # Incremental MPE processing
│   │   ├── files_management/ # Agnostic file operations
│   │   └── ...            # Other service domains
│   └── transport/         # External communication adapters
│       ├── http/          # HTTP handlers and routes
│       └── rmq/           # RabbitMQ consumers
├── pkg/                   # Public library code
│   └── timezone/          # Timezone utilities
├── mocks/                 # Generated mocks for testing
└── data/                  # Test data files
```

## Architecture Patterns

### Layered Architecture

- **Transport Layer** (`internal/transport/`): External communication only
- **Service Layer** (`internal/services/`): Business logic and orchestration
- **Repository Layer** (`internal/repositories/`): Data access only

Dependencies MUST flow inward: Transport → Service → Repository

### Dependency Injection

- All dependencies injected via constructors
- Use interfaces for all external dependencies
- Wire dependencies in `cmd/container.go`

### Factory Pattern

- Use factories to select operations based on message properties
- Structure: Top-level factory → Network factory → Operation

## Code Generation Rules

When generating code, Copilot MUST:

1. **Reference Real Code**: Use `@path/to/file.go` to reference existing patterns
2. **Follow Existing Patterns**: Match naming, structure, and organization
3. **Include Error Handling**: Always handle errors, never ignore them
4. **Add Observability**: Include structured logging and tracing
5. **Validate Input**: Validate all external input early
6. **Use Context**: Propagate `context.Context` through all layers
7. **Write Tests**: Generate tests for business logic

## Path-Specific Instructions

For detailed, context-specific rules, see:

- `.github/instructions/architecture.instructions.md` - Architecture and SOLID principles
- `.github/instructions/golang.instructions.md` - Go-specific rules and tooling
- `.github/instructions/coding-conventions.instructions.md` - Naming and formatting
- `.github/instructions/observability.instructions.md` - Logging, tracing, metrics
- `.github/instructions/security.instructions.md` - Security practices
- `.github/instructions/testing.instructions.md` - Testing patterns

## Extending This System

To add new instructions:

1. Create a new `.instructions.md` file in `.github/instructions/`
2. Add frontmatter with `applyTo` field for path patterns
3. Keep content focused and under 500 lines
4. Reference real code using `@path/to/file.go`
5. Include correct and incorrect examples
6. Update this file to reference the new instruction file

## Examples of Correct Patterns

### Service Implementation

```go
// ✅ CORRECT: Service with dependency injection
type authorizedService struct {
    operationFactory interfaces.OperationFactory[authorizer.AuthorizedMessage]
    eventsRepo       interfaces.EventsRepository
}

func NewAuthorizedService(
    operationFactory interfaces.OperationFactory[authorizer.AuthorizedMessage],
    eventsRepo interfaces.EventsRepository,
) interfaces.AuthorizerService {
    return &authorizedService{
        operationFactory: operationFactory,
        eventsRepo:       eventsRepo,
    }
}
```

### Error Handling

```go
// ✅ CORRECT: Error handling with logging
if err != nil {
    logrus.WithContext(ctx).
        WithError(err).
        WithFields(msg.LogFields()).
        Error("failed to process transaction")
    return err
}
```

### Context Propagation

```go
// ✅ CORRECT: Context as first parameter
func (as *authorizedService) Process(
    ctx context.Context, // First parameter
    customer *configuration.CustomerConfig,
    msg *authorizer.AuthorizedMessage,
) error {
    // Propagate context
    return op.Process(ctx, customer, msg)
}
```

## Anti-Patterns (NEVER Generate)

- ❌ Business logic in transport layer (consumers/handlers)
- ❌ Direct database access in services (use repositories)
- ❌ Hardcoded secrets or configuration
- ❌ String concatenation in logs
- ❌ Ignored errors (`_ = err`)
- ❌ Panic in production code paths
- ❌ God objects or services
- ❌ Missing error handling
- ❌ Missing context propagation
- ❌ Unvalidated external input
