# GitHub Copilot Instructions

This repository uses a structured, multi-file instruction system to guide GitHub Copilot's code generation behavior. These instructions enforce deterministic, production-grade engineering practices across the entire codebase.

## Project Overview

**bunmq** is a resilient and robust RabbitMQ library for Go applications, providing:

- High-level abstractions for topology management (exchanges, queues, bindings)
- Message publishing with deadline support and automatic reconnection
- Type-safe message consuming with reflection-based dispatching
- Built-in retry mechanisms with exponential backoff
- Dead letter queue (DLQ) support
- Automatic connection/channel recovery using `NotifyClose` and `NotifyCancel`
- OpenTelemetry distributed tracing integration

### Tech Stack

- **Language**: Go 1.25+
- **Message Broker**: RabbitMQ via `github.com/rabbitmq/amqp091-go`
- **Logging**: Logrus `github.com/sirupsen/logrus`
- **Tracing**: OpenTelemetry `go.opentelemetry.io/otel`
- **Testing**: Go standard testing with mocks
- **Linting**: golangci-lint v2.4+
- **Security**: gosec

## Instruction System Architecture

This instruction system is organized into focused, single-responsibility files:

- **Repository-wide rules** (this file): Global principles, architecture overview, and system organization
- **Path-specific instructions** (`.github/instructions/`): Targeted rules for specific file types and directories

### Instruction File Structure

```
.github/
├── copilot-instructions.md                    # Main entry point (this file)
└── instructions/
    ├── project-structure.instructions.md      # Directory structure, file organization
    ├── architecture.instructions.md           # SOLID principles, clean architecture, patterns
    ├── golang.instructions.md                 # Go-specific rules, idioms, mandatory tooling
    ├── coding-conventions.instructions.md     # Naming, formatting, code style
    ├── observability.instructions.md          # Logging, tracing, OpenTelemetry
    ├── security.instructions.md               # Security practices, vulnerability prevention
    ├── testing.instructions.md                # Testing patterns, coverage, mocks
    └── ai-behavior.instructions.md            # AI-specific directives and constraints
```

Each instruction file:
- Uses YAML frontmatter with `applyTo` for path-specific targeting
- Follows strict rule format: Description, When it applies, Copilot MUST/MUST NOT, Examples
- References real codebase files using `@path/to/file.go` syntax
- Contains actionable, enforceable directives (not suggestions)

## Core Engineering Principles

All code generated by Copilot MUST follow these non-negotiable principles:

### 1. SOLID Principles

- **Single Responsibility**: Each file, struct, and function has ONE clear purpose
- **Dependency Inversion**: Depend on interfaces, not concrete implementations
- **Interface Segregation**: Keep interfaces small and focused
- **No God Objects**: Prohibit god structs or mixed responsibilities

### 2. Clean Code

- **Small Functions**: Functions under 30 lines (excluding comments)
- **Meaningful Names**: Descriptive, intention-revealing names
- **Clear Separation**: Distinct boundaries between components
- **No Magic Values**: Use constants for semantic values
- **Early Returns**: Use guard clauses, avoid deep nesting

### 3. 12-Factor App Principles

- **Configuration**: Support environment-based configuration
- **Stateless**: Library code must be stateless and thread-safe
- **Logs**: Treat as event streams (structured logging to stdout)
- **Explicit Dependencies**: All dependencies clearly defined in interfaces

### 4. Observability (MANDATORY)

- **Structured Logging**: Use Logrus with fields, never string concatenation
- **Log Levels**: Debug, Info, Warn, Error (use appropriately)
- **Context Propagation**: Always propagate `context.Context`
- **Tracing**: Use OpenTelemetry for significant operations
- **No Secrets**: Never log passwords, tokens, or sensitive data

### 5. Cloud-Native Design

- **Container-First**: Library compatible with containerized environments
- **Graceful Shutdown**: Handle shutdown signals properly (SIGTERM, SIGINT)
- **Connection Resilience**: Automatic reconnection with exponential backoff
- **Health Awareness**: Support health checks and monitoring

## Quality Gates (MANDATORY)

All code MUST pass these tools without warnings:

1. **golangci-lint**: Zero warnings (`make lint`)
2. **go vet**: No issues
3. **gosec**: No security vulnerabilities (`make sec`)
4. **go test**: All tests passing (`make test`)
5. **gofmt**: Properly formatted
6. **Coverage**: Maintain 90%+ test coverage (`make test-coverage-threshold`)

## Project Structure

```
bunmq/
├── connection.go           # RMQConnection interface definition
├── connection_manager.go   # Connection management with auto-reconnection
├── channel.go              # Channel wrapper and management
├── topology.go             # Topology builder for exchanges, queues, bindings
├── queue.go                # Queue definitions with retry/DLQ configuration
├── exchange.go             # Exchange definitions (direct, topic, fanout, headers)
├── binding.go              # Binding configuration between exchanges and queues
├── publisher.go            # Message publishing with tracing and deadlines
├── dispatcher.go           # Message consumption and handler dispatching
├── tracing.go              # OpenTelemetry integration for AMQP headers
├── options.go              # Publishing options and message metadata
├── errors.go               # Domain-specific error types
├── mocks.go                # Mock implementations for testing
├── *_test.go               # Unit tests (alongside source files)
├── examples/               # Usage examples
│   └── main.go
├── Makefile                # Build automation (test, lint, sec)
├── .gosec.json             # Security scanner configuration
├── codecov.yml             # Code coverage configuration
├── go.mod                  # Module definition
└── go.sum                  # Dependency checksums
```

## Architecture Patterns

### Interface-Based Design

All major components are defined as interfaces for testability and flexibility:

Reference: `@connection.go`

```go
type RMQConnection interface {
    Channel() (*amqp.Channel, error)
    IsClosed() bool
    Close() error
    NotifyClose(receiver chan *amqp.Error) chan *amqp.Error
}
```

### Builder Pattern for Configuration

Use builder pattern for complex object configuration:

Reference: `@queue.go`, `@topology.go`

```go
queueDef := bunmq.NewQueue("my-queue").
    Durable(true).
    WithMaxLength(100_000).
    WithRetry(time.Second*10, 3).
    WithDLQ()
```

### Type-Safe Message Handlers

Use reflection for type-safe handler registration:

Reference: `@dispatcher.go`

```go
type ConsumerHandler = func(ctx context.Context, msg any, metadata *DeliveryMetadata) error
```

## Code Generation Rules

When generating code, Copilot MUST:

1. **Reference Real Code**: Use `@path/to/file.go` to reference existing patterns
2. **Follow Existing Patterns**: Match naming, structure, and organization
3. **Include Error Handling**: Always handle errors, never ignore them
4. **Add Observability**: Include structured logging and tracing
5. **Validate Input**: Validate all external input early
6. **Use Context**: Propagate `context.Context` as first parameter
7. **Write Tests**: Generate tests for all public functions
8. **Thread Safety**: Ensure concurrent-safe code with proper synchronization (sync.Mutex, sync.RWMutex)
9. **Resource Cleanup**: Use defer for resource cleanup (channels, connections)

## Build & Validation Commands

```bash
# Install development tools
make install

# Run tests
make test

# Run tests with coverage
make test-coverage

# Check coverage threshold (90%)
make test-coverage-threshold

# Run linter
make lint

# Run security scanner
make sec

# Generate security reports
make sec-report
```

## Examples of Correct Patterns

### Interface Definition

Reference: `@publisher.go`

```go
// ✅ CORRECT: Small, focused interface with clear documentation
type Publisher interface {
    Publish(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error
    PublishDeadline(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error
    PublishQueue(ctx context.Context, queue string, msg any, options ...*Option) error
    PublishQueueDeadline(ctx context.Context, queue string, msg any, options ...*Option) error
}
```

### Error Handling with Logging

Reference: `@publisher.go`

```go
// ✅ CORRECT: Validate input and log errors with context
func (p *publisher) Publish(ctx context.Context, exchange, routingKey string, msg any, options ...*Option) error {
    if exchange == "" {
        logrus.WithContext(ctx).Error("exchange cannot be empty")
        return fmt.Errorf("exchange cannot be empty")
    }
    return p.publish(ctx, exchange, routingKey, msg, options...)
}
```

### OpenTelemetry Integration

Reference: `@tracing.go`

```go
// ✅ CORRECT: Implement TextMapCarrier for trace propagation
type AMQPHeader amqp.Table

func (h AMQPHeader) Set(key, val string) {
    key = strings.ToLower(key)
    h[key] = val
}

func (h AMQPHeader) Get(key string) string {
    key = strings.ToLower(key)
    value, ok := h[key]
    if !ok {
        return ""
    }
    toString, ok := value.(string)
    if !ok {
        return ""
    }
    return toString
}
```

### Graceful Shutdown

Reference: `@dispatcher.go`

```go
// ✅ CORRECT: Handle shutdown signals properly
signalCh := make(chan os.Signal, 1)
signal.Notify(signalCh, syscall.SIGINT, syscall.SIGTERM)
```

## Path-Specific Instructions

For detailed, context-specific rules, see:

- `.github/instructions/architecture.instructions.md` - SOLID and design patterns
- `.github/instructions/golang.instructions.md` - Go-specific rules and tooling
- `.github/instructions/coding-conventions.instructions.md` - Naming and formatting
- `.github/instructions/observability.instructions.md` - Logging, tracing
- `.github/instructions/security.instructions.md` - Security practices
- `.github/instructions/testing.instructions.md` - Testing patterns

## Extending This System

To add new instructions:

1. Create a new `.instructions.md` file in `.github/instructions/`
2. Add frontmatter with `applyTo` field for path patterns (e.g., `"**/*.go"`)
3. Keep content focused and under 500 lines
4. Reference real code using `@path/to/file.go`
5. Include correct and incorrect examples
6. Update this file to reference the new instruction file

## Anti-Patterns (NEVER Generate)

- ❌ Ignoring errors (`_ = err`)
- ❌ String concatenation in logs (`log.Print("error: " + err.Error())`)
- ❌ Hardcoded configuration values
- ❌ Missing context propagation
- ❌ Panic in library code (except in init for programmer errors)
- ❌ God structs with many responsibilities
- ❌ Missing input validation
- ❌ Unprotected concurrent access to shared state
- ❌ Blocking operations without timeout or context
- ❌ Missing graceful shutdown handling
- ❌ Leaking goroutines or resources
